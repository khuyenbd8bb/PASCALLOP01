_G.Key = "AnimeWeapons"
local key = _G.Key
local Access = "AnimeWeapons"

if game.PlaceId == 79189799490564 and key == Access then
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Exunys/Config-Library/main/Main.lua"))()
local TextChatService = game:GetService("TextChatService")

local Players = game:GetService("Players")
local player = Players.LocalPlayer

local distance = 500
local waveGui = game:GetService("Players").LocalPlayer.PlayerGui.Screen.Hud.gamemode.Raid.wave.amount
local roomGui = game:GetService("Players").LocalPlayer.PlayerGui.Screen.Hud.gamemode.Dungeon.room.amount
local room = tonumber((string.gsub(roomGui.Text, "Room: ", "")))
local wave = tonumber((string.gsub(waveGui.Text, "Room: ", "")))
if not wave then wave = tonumber((string.gsub(waveGui.Text, "Wave: ", ""))) end

local gachaZone
local targetWave = 500
local targetRoom = 50
local attackRangePart 
local attackRange 

local monsterList = {} -- Name, HumanoidRoot
local nameList = {} -- Table HUB
local targetList = {}
local dungeonList = {};   local raidList = {}
local targetDungeon = {}; local targetRaid = {}
local dungeonNumber = {}; local raidNumber = {};
local dungeonTime  =  {}; local raidTime  =  {}
local teleportBackMap = "None"

local repeatTime = 1
local locationList = {}; local locationNumber = {}; 
local locationTargetList = {}
local isTeleportFarm = false
local isTeleportHatch = false

local isHatch = false
local inDungeon = false
local isDungeon = false
local keepRunning = false
local isKilling = false
local isRankUp = false
local isFuse = false
local currentTime = os.date("*t") -- Use os.date() not os.time()
-- Main
task.spawn(function()
	while true do
		--warn(inDungeon, isDungeon)
		task.wait(5)
	end
end)
task.spawn(function()
    while true do
        task.wait()
        if #workspace.Zones:GetChildren() < 1 then continue end
        gachaZone = workspace.Zones:GetChildren()[1]
        
        gachaZone = gachaZone:FindFirstChild("Utility")
        if not gachaZone then continue end 
        
        gachaZone = gachaZone:FindFirstChild("Gacha Machine")
        if not gachaZone then continue end 
        
        gachaZone = gachaZone:FindFirstChild("Circle")
        if not gachaZone then continue end 
        task.wait(1)
    end
end)

local function loadData()
    local ok = true
    if not isfolder("TigerHub") or not isfile("TigerHub/monsterList.json") then
        makefolder("TigerHub")
        writefile("TigerHub/monsterList.json", "[]") -- Changed from {} to [] for array
        ok = false
    end
    
    if not isfolder("TigerHub") or not isfile("TigerHub/locationList.json") then
        makefolder("TigerHub")
        writefile("TigerHub/locationList.json", "[]") -- Changed from {} to [] for array
        ok = false
    end
    if not ok then return end
    -- Read the file content first, then decode it
    local monsterJsonContent = readfile("TigerHub/monsterList.json")
    local monsterTable = Library.Decode(monsterJsonContent)
    
    nameList = monsterTable

    monsterJsonContent = readfile("TigerHub/locationList.json")
    monsterTable = Library.Decode(monsterJsonContent)
    locationList = monsterTable

    for i, locationObj in ipairs(monsterTable) do
        -- Extract the number
        table.insert(locationNumber, locationObj.number)
        
        -- Convert the pos string to Vector3
        local posString = locationObj.pos
        local x, y, z = posString:match("Vector3_%(([%d%.%-]+),%s*([%d%.%-]+),%s*([%d%.%-]+)%)")
        
        if x and y and z then
            locationList[i] = {
                number = locationObj.number,
                pos = Vector3.new(tonumber(x), tonumber(y), tonumber(z))
            }
        end
    end

end

task.spawn(function()
   attackRangePart =  workspace:FindFirstChild("AttackRange")
   if not attackRangePart then return end
   if attackRangePart then attackRangePart = attackRangePart.Part end
   attackRange = attackRangePart.Size.X/2
end)

local function FindHRP(player)
    for _, zone in ipairs(workspace.Zones:GetChildren()) do
        local chars = zone:FindFirstChild("Characters")
        if chars then
            local char = chars:FindFirstChild(player.Name)
            if char then
                return char:FindFirstChild("HumanoidRootPart")
            end
        end
    end
    return nil
end

local function FindHumanoid(player)
    for _, zone in ipairs(workspace.Zones:GetChildren()) do
        local chars = zone:FindFirstChild("Characters")
        if chars then
            local char = chars:FindFirstChild(player.Name)
            if char then
                return char:FindFirstChild("Humanoid")
            end
        end
    end
    return nil
end

local hrp = FindHRP(player)
local humanoid = FindHumanoid(player)

player.CharacterAdded:Connect(function(character)
    hrp = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
    print("Character updated!")
end)

roomGui:GetPropertyChangedSignal("Text"):Connect(function()
    room = tonumber((string.gsub(roomGui.Text, "Room: ", "")))
end)
waveGui:GetPropertyChangedSignal("Text"):Connect(function()
    wave = tonumber((string.gsub(waveGui.Text, "Room: ", "")))
    if not wave then
        wave = tonumber((string.gsub(waveGui.Text, "Wave: ", "")))
    end
end)

attackRangePart:GetPropertyChangedSignal("Size"):Connect(function()
    attackRange = attackRangePart.Size.X/2
end)
task.spawn(function()
    while true do 
        local args = {
            "Settings",
            {
                "AutoAttack",
                true
            }
        }
        game:GetService("ReplicatedStorage"):WaitForChild("Reply"):WaitForChild("Reliable"):FireServer(unpack(args))
        task.wait(1)
    end
end)

local function getDistance(obj1, obj2)
    local pos1, pos2
    if obj1:IsA("Model") then
        pos1 = obj1:GetPivot().Position
    elseif obj1:IsA("BasePart") then
        pos1 = obj1.Position
    end

    if obj2:IsA("Model") then
        pos2 = obj2:GetPivot().Position
    elseif obj2:IsA("BasePart") then
        pos2 = obj2.Position
    end
    
    return (pos1 - pos2).Magnitude
end
local function getPosition(obj1)
    if obj1:IsA("Model") then
        return obj1:GetPivot().Position
    elseif obj1:IsA("BasePart") then
        return obj1.Position
    else
        return nil
    end
end
--- FFarm1
local function resetEnemiesList()
    local monsters = workspace.Enemies:GetChildren()
    local nameSet = {}           -- helper table for checking duplicates
    table.clear(nameList)
    table.clear(monsterList)

    for _, monster in pairs(monsters) do
        
        if monster.Name == "" or not monster.Name then 
            task.wait()
            continue 
        end
        local nameText = monster.Name
        
        if monster.Head.Transparency ~= 0 then continue end
        if getDistance(hrp, monster.HumanoidRootPart) >= distance then continue end

        if not nameSet[nameText] then
            table.insert(monsterList, nameText)
            nameSet[nameText] = true
            table.insert(nameList, nameText)
        end
    end

end

local function kill(monster)
    local head = monster:FindFirstChild("Head")
    local hrpToFeet = (hrp.Size.Y / 2) + (humanoid.HipHeight or 2)
    local safeHeight = 0
    --local alive = head.Transparency
    if inDungeon then return end 
    local headPos = getPosition(head)
    local targetPosition = headPos + Vector3.new(5, hrpToFeet + safeHeight, 5)        
    hrp.CFrame = CFrame.new(targetPosition)

    local stillTarget = false
    for _, target in pairs(targetList) do
        if not monster or not monster.Name then return end
        if (target == monster.Name) then
            stillTarget = true
            break;
        end
    end   
    local alive = true
    local connection
    connection = monster.ChildRemoved:Connect(function(child)
        connection:Disconnect()
        alive = false
    end)
    while keepRunning and stillTarget and not inDungeon and alive do
        hrp.CFrame = CFrame.new(targetPosition)
        if getDistance(attackRangePart, monster) > distance then 
            return
        end
        stillTarget = false
        for _, target in pairs(targetList) do
            if not monster.Parent or not monster then return end
            if monster.Name == "" then return end
            if (target == monster.Name) then
                stillTarget = true
                break;
            end
        end
        task.wait()
    end
end

local function check()
    local monsters = workspace.Enemies:GetChildren()
    for _, monster in pairs(monsters) do
        if not keepRunning then break end
        if not monster:FindFirstChild("Head") then return end
        local Head = monster.Head
        if Head.Transparency ~= 0 then continue end
        local dis = getDistance(attackRangePart, monster)
        if dis >= distance or dis <= attackRange then continue end

        if not monster then continue end
        if monster.Name == "" or not monster.Name then 
            task.wait()
            continue
        end
        local nameText = monster.Name

        for _, target in ipairs(targetList) do
            if (target == nameText) then
                isKilling = true
                if inDungeon then return end
                kill(monster)
                isKilling = false
                break
            end
        end
    end
end

local function autoFarm()
    while keepRunning do
        if not isKilling and not inDungeon then
            check()
            task.wait()
        end
        task.wait()
    end
end

--DDungeon
task.spawn(function()
    table.insert(dungeonList, "Easy");   dungeonNumber["Easy"] =   1; dungeonTime["Easy"] = 0
    table.insert(dungeonList, "Medium"); dungeonNumber["Medium"] = 2; dungeonTime["Medium"] = 20
    table.insert(dungeonList, "Hard");   dungeonNumber["Hard"] =   3; dungeonTime["Hard"] = 40
    
    table.insert(raidList, "Shinobi");   raidNumber["Shinobi"] = 1; raidTime["Shinobi"] = 10
end)


local function teleportBack()
    if teleportBackMap == "None" then return end
    local args = {
        "Zone Teleport",
        {
            teleportBackMap
        }
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Reply"):WaitForChild("Reliable"):FireServer(unpack(args))
	warn("TELEPORT BACK")
end
local function isPlayerInZone(zone)
    local chars = zone:FindFirstChild("Characters")
    if not chars then return false end
    chars = chars:FindFirstChild(player.Name)
    if not chars then return false end
    return true
end

local function checkFolderDungeonZones()
    local location = workspace.Zones:GetChildren()
    if location[1] and string.find(location[1].Name, "Dungeon:") and isPlayerInZone(location[1]) then return true end
    if #location ~= 1 and location[2] and string.find(location[2].Name, "Dungeon:") and isPlayerInZone(location[2]) then return true end
    return false
end

local function checkFolderRaidZones()
    local location = workspace.Zones:GetChildren()
    if location[1] and string.find(location[1].Name, "Raid:") and isPlayerInZone(location[1]) then return true end
    if #location ~= 1 and location[2] and string.find(location[2].Name, "Raid:") and isPlayerInZone(location[2]) then return true end
    return false
end

local function killDungeon(monster)
    if not inDungeon then return end
    if not monster then return end
    local head = monster:FindFirstChild("Head")
    if not head then return end
    local hrpToFeet = (hrp.Size.Y / 2) + (humanoid.HipHeight or 2)
    local safeHeight = 0
    --local alive = head.Transparency
    local headPos = getPosition(head)
    local targetPosition = headPos + Vector3.new(5, hrpToFeet + safeHeight, 3)        
    hrp.CFrame = CFrame.new(targetPosition)
    while isDungeon and inDungeon and head.Transparency == 0 and monster and monster.Parent do
        if getDistance(attackRangePart, monster) > distance then 
            return
        end
        if checkFolderRaidZones() and wave > targetWave then 
            inDungeon = false
            teleportBack()
            return
        end
        hrp.CFrame = CFrame.new(targetPosition)
        if not checkFolderDungeonZones() and not checkFolderRaidZones() then 
            inDungeon = false
            teleportBack()
            return
        end
        task.wait()
    end
end

local function checkDungeon() 
    while not checkFolderDungeonZones() and not checkFolderRaidZones() and inDungeon and isDungeon do
        task.wait()
    end
    
    while room <= targetRoom and inDungeon and isDungeon do 
        
        local monsters = workspace.Enemies:GetChildren()
        if (#monsters == 0) then 
            if not checkFolderDungeonZones() and not checkFolderRaidZones() then inDungeon = false end
            task.wait()
        end
        if not checkFolderDungeonZones() and not checkFolderRaidZones() then return end
        for _, monster in pairs(monsters) do
            if not isDungeon then return end
            if not inDungeon then return end
            local Head = monster:FindFirstChild("Head")
            if not Head then continue end
            if Head.Transparency ~= 0 then continue end
            local dis = getDistance(attackRangePart, monster)
            if dis >= distance or dis <= attackRange then continue end
            killDungeon(monster)
            task.wait()
        end
    task.wait()
    end
end

local function joinDungeon()
    if inDungeon then return end
    if checkFolderDungeonZones() then
        inDungeon = true
        checkDungeon()
        inDungeon = false
        while checkFolderDungeonZones() do
            task.wait()
        end
        if not checkFolderDungeonZones() and isDungeon then teleportBack() end
        return 
    end
    
    if checkFolderRaidZones() then
        inDungeon = true
        checkDungeon()
        inDungeon = false
        while checkFolderRaidZones() do
            task.wait()
        end
        if (not checkFolderRaidZones() or wave > targetWave) and isDungeon then teleportBack() end
        return 
    end
    
    local isTargetDungeon = false
    local isTargetRaid = false
    currentTime = os.date("*t")
    for _, dungeon in pairs(targetDungeon) do
        if dungeonTime[dungeon] == currentTime.min then 
            isTargetDungeon = dungeon
        end
    end
    for _, raid in pairs(targetRaid) do
        if raidTime[raid] == currentTime.min or raidTime[raid] + 30 == currentTime.min then 
            isTargetRaid = raid
        end
    end
    if not isTargetDungeon and not isTargetRaid then return end
    inDungeon = true
    if isTargetDungeon then 
        local number = dungeonNumber[isTargetDungeon]
        local Dungeon = "Dungeon:".. tostring(number)
        local args = {
            "Join Gamemode",
            {
                Dungeon
            }
        }
        game:GetService("ReplicatedStorage"):WaitForChild("Reply"):WaitForChild("Reliable"):FireServer(unpack(args))
        checkDungeon()
        inDungeon = false
        while checkFolderDungeonZones() do
            task.wait()
        end
        if not checkFolderDungeonZones() and isDungeon then teleportBack() end
    elseif isTargetRaid then 
        local number = raidNumber[isTargetRaid]
        local Raid = "Raid:".. tostring(number)
        local args = {
            "Join Gamemode",
            {
                Raid
            }
        }
        game:GetService("ReplicatedStorage"):WaitForChild("Reply"):WaitForChild("Reliable"):FireServer(unpack(args))
        checkDungeon()
        inDungeon = false
        while checkFolderRaidZones() do
            task.wait()
        end
        if (not checkFolderRaidZones() or wave > targetWave) and isDungeon then teleportBack() end
    end
    
end
local function autoFarmDungeon()
    while (isDungeon) do
        joinDungeon()
        task.wait(1)    
    end
end
-- SStronger
local function autoFuse()
    while isFuse do
        local args = {
        "Weapon Fuse All"
        }
        game:GetService("ReplicatedStorage"):WaitForChild("Reply"):WaitForChild("Reliable"):FireServer(unpack(args))
        task.wait(5)
    end 
end

local function autoRankUp()
    while isRankUp do
        local args = {
        "RankUp"
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Reply"):WaitForChild("Reliable"):FireServer(unpack(args))
    task.wait(5)
    end 
end
local canRepeat = true
local function autoHatch()
    while isHatch do
        if not gachaZone or typeof(gachaZone) ~= "Instance" or typeof(hrp) ~= "Instance" then 
            task.wait() 
            continue 
        end
        if getDistance(gachaZone, hrp) <= 8.5 and canRepeat then
            task.wait(0.1)
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local Reliable = ReplicatedStorage.Reply.Reliable -- RemoteEvent 
            Reliable:FireServer(
                "Gacha Auto"
            )
            canRepeat = false   
        end 
        if getDistance(gachaZone, hrp) > 9 then 
            canRepeat = true
        end
        task.wait()
    end
end

-- LLocation 
local function teleportTo(target)
    for _, location in ipairs(locationList) do
        if (location.number == target) then
            
            local Pos = location.pos
            if (getPosition(hrp) - Pos).Magnitude  > distance then return end
            
            local targetPosition = Pos        
            if inDungeon then return end 
            hrp.CFrame = CFrame.new(targetPosition)
            break
        end
    end
    task.wait(repeatTime)
end
local function autoTeleportFarm()
    while isTeleportFarm do
        if inDungeon then 
            task.wait()
            continue 
        end
        for _, location in ipairs(locationTargetList) do
            teleportTo(location)
        end

        if not inDungeon and isTeleportHatch and gachaZone and typeof(gachaZone) == "Instance" and typeof(hrp) == "Instance"  then
            local hrpToFeet = (hrp.Size.Y / 2) + (humanoid.HipHeight or 2)
            local safeHeight = 0
            --local alive = head.Transparency
            local headPos = getPosition(gachaZone)
            local targetPosition = headPos + Vector3.new(3, hrpToFeet + safeHeight, 3)      
            hrp.CFrame = CFrame.new(targetPosition)
            task.wait(0.5)
        end

        task.wait()
    end
end
local function addLocation()
    local Position = hrp.Position
    local size = #locationList
    size = "Location #" .. tostring(size + 1)
    table.insert(locationList, {number = size, pos = Position})
end

-- GGUI
    
    local Window = Fluent:CreateWindow({
        Title = "Tiger HUB | Anime Weapons | Version: 01",
        TabWidth = 160,
        Size = UDim2.fromOffset(580, 460),
        Acrylic = true, -- The blur may be detectable, setting this to false disables blur entirely
        Theme = "Darker",
        MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind
    })

    TextChatService.MessageReceived:Connect(function(message)
        if not message or not message.TextSource then return end
        if not (message.TextSource.Name == player.Name) then return end
        if #message.Text == 1 then 
            Window:Minimize()
        end
    end)
    
    local tabs = {
        Main = Window:AddTab({ Title = "Farm", Icon = "swords" }),
        Farm2 = Window:AddTab({ Title = "Location Farm", Icon = "swords" }),
        Dungeon = Window:AddTab({ Title = "Dungeons/ Raids", Icon = "skull" }),
        Powers = Window:AddTab({ Title = "Auto Stronger", Icon = "flame" }),
        Settings = Window:AddTab({ Title = "Player Config", Icon = "user-cog" })
    }
    
    local option1 = Fluent.Options
    do
        loadData()
        local MultiDropdown = tabs.Main:AddDropdown("MultiDropdown", {
            Title = "Select Enemies on map",
            Description = "Select Enemies to kill",
            Values = {},
            Multi = true,
            Default = {},
        })
        MultiDropdown:OnChanged(function(selectedValues)
            table.clear(targetList)

            for name, state in pairs(selectedValues) do
                if state then
                    table.insert(targetList, name)
                end
            end        
        end)

        local resetButton = tabs.Main:AddButton({
            Title = "Reset Enemies",
            Description = "Always Reset Enemies after change map",
            Callback = function() 
                MultiDropdown:SetValue({})
                resetEnemiesList() 
                MultiDropdown:SetValues(nameList)
                Library:SaveConfig("TigerHub/monsterList.json", nameList)
            end
        })
        MultiDropdown:SetValues(nameList)

        
        local toogleFarm = tabs.Main:AddToggle("toogleFarm", {Title = "Auto Farm Selected Enemies", Default = false})
        toogleFarm:OnChanged(function()
            keepRunning = toogleFarm.Value
            isKilling = false
            if (toogleFarm.Value) then
                task.spawn(function() 
                    autoFarm()
                end)
            end
        end)
        -- LLocation FFarm
        local locationDropdown = tabs.Farm2:AddDropdown("locationDropdown", {
            Title = "Location Selection",
            Description = "Select Location to teleport",
            Values = {},
            Multi = true,
            Default = {},
        })
        
        locationDropdown:OnChanged(function(selectedValues)
            table.clear(locationTargetList)

            for number, state in pairs(selectedValues) do
                if state then
                    table.insert(locationTargetList, number)
                end
            end
        end)

        
        local addLocation = tabs.Farm2:AddButton({
            Title = "Add Location to dropdown",
            Description = "your currently position",
            Callback = function() 
                addLocation()
                locationDropdown:SetValue({})
                local list = {}
                for _, location in ipairs(locationList) do
                    table.insert(list, location.number)
                end
                locationDropdown:SetValues(list)
                Library:SaveConfig("TigerHub/locationList.json", locationList)
            end
        })

        locationDropdown:SetValues(locationNumber)
        
        local toogleTeleport = tabs.Farm2:AddToggle("toogleTeleport", {Title = "Auto Teleport accross all ur location", Default = false})
        toogleTeleport:OnChanged(function()
            isTeleportFarm = toogleTeleport.Value
            if (isTeleportFarm) then
                task.spawn(function() 
                    autoTeleportFarm()
                end)
            end
        end)
        
        local teleportSpeed = tabs.Farm2:AddInput("Input", {
            Title = "Teleport Delay (Seconds)",
            Default = 2,
            Placeholder = "Placeholder",
            Numeric = true, -- Only allows numbers
            Finished = false, -- Only calls callback when you press enter
            Callback = function(Value)
            end
        })

        teleportSpeed:OnChanged(function()
            if teleportSpeed.Value == nil or teleportSpeed.Value == "" then
                repeatTime = 1 else
                repeatTime = math.max(teleportSpeed.Value, 0.3)
            end
        end)

        local clearLocation = tabs.Farm2:AddButton({
            Title = "Clear all location",
            Description = "W Farm",
            Callback = function() 
                locationDropdown:SetValues({})
                table.clear(locationList)
            end
        })

        local toogleLocationHatch = tabs.Farm2:AddToggle("toogleLocationHatch", {Title = "Location Gacha", Default = false, Description = "Req(Auto Gacha + Location farm)",})
        toogleLocationHatch:OnChanged(function()
            isTeleportHatch = toogleLocationHatch.Value
        end)
        --Dungeon
        local dropdownDungeon = tabs.Dungeon:AddDropdown("dropdownDungeon", {
            Title = "Dungeons",
            Description = "Select Dungeon to auto farm",
            Values = {},
            Multi = true,
            Default = {},
        })
        dropdownDungeon:SetValues(dungeonList)

        dropdownDungeon:OnChanged(function(selectedValues)
            table.clear(targetDungeon)

            for name, state in pairs(selectedValues) do
                if state then
                    table.insert(targetDungeon, name)
                end
            end
        end)

        local dropdownRaid = tabs.Dungeon:AddDropdown("dropdownRaid", {
            Title = "Raids",
            Description = "Select Raids to auto farm",
            Values = {},
            Multi = true,
            Default = {},
        })
        dropdownRaid:SetValues(raidList)

        dropdownRaid:OnChanged(function(selectedValues)
            table.clear(targetRaid)

            for name, state in pairs(selectedValues) do
                if state then
                    table.insert(targetRaid, name)
                end
            end
        end)

        local toogleFarmDungeon = tabs.Dungeon:AddToggle("toogleFarmDungeon", {Title = "Auto Farm Dungeons/ Raids", Default = false})
        toogleFarmDungeon:OnChanged(function()
            isDungeon = toogleFarmDungeon.Value
            if isDungeon then 
                
                autoFarmDungeon()
            end
        end)

        local teleportBackDropdown = tabs.Dungeon:AddDropdown("teleportBackDropdown", {
            Title = "Teleport Back after Dung/Raid",
            Description = "Select Location to teleport",
            Values = {"None", "Naruto","DragonBall", "OnePiece", "DemonSlayer"},
            Multi = false,
            Default = "None",
        })
        
        teleportBackDropdown:OnChanged(function(selectedValues)
            teleportBackMap = selectedValues
        end)

        local inputTargetWave = tabs.Dungeon:AddInput("inputTargetWave", {
            Title = "Target Wave (Raid)",
            Description = "Leave after this wave",
            Default = 500,
            Placeholder = "Placeholder",
            Numeric = true, -- Only allows numbers
            Finished = true, -- Only calls callback when you press enter
            Callback = function(Value)
            end
        })
        inputTargetWave:OnChanged(function()
            if inputTargetWave.Value == nil or not inputTargetWave.Value then
                targetWave = 100 else
                targetWave = tonumber(inputTargetWave.Value)
            end
        end)

        -- SStronger
        local toogleFuse = tabs.Powers:AddToggle("toogleFuse", {Title = "Auto Fuse Weapons", Default = false})
        toogleFuse:OnChanged(function()
            isFuse = toogleFuse.Value
            autoFuse()
        end)
        local toggleRank = tabs.Powers:AddToggle("toggleRank", {Title = "Auto RankUp", Default = false})
        toggleRank:OnChanged(function()
            isRankUp = option1.toggleRank.Value
            task.spawn(function() autoRankUp() end)
        end)
        local toggleHatch = tabs.Powers:AddToggle("toggleHatch", {Title = "Auto Gacha(nearby)", Default = false})
        toggleHatch:OnChanged(function()
            isHatch = option1.toggleHatch.Value
            task.spawn(function() autoHatch() end)
        end)
        tabs.Powers:AddSection("Auto Powers")
        -- Player
        local close = tabs.Settings:AddParagraph({
            Title = "chat ONE LETTER on chat -> Gui will show/ hide",
            Content = "Click LeftControl To Hide/ Show Hub"
        })

        local fpsBoost =  tabs.Settings:AddToggle("fpsBoost", {Title = "Reduce Lag/ FPS Boost", Default = false})
        fpsBoost:OnChanged(function()
            if fpsBoost.Value then
                loadstring(game:HttpGet("https://raw.githubusercontent.com/khuyenbd8bb/RobloxKaitun/refs/heads/main/FPS%20Booster.lua"))()
            end
        end)

        function Parent(GUI)
            if syn and syn.protect_gui then
                syn.protect_gui(GUI)
                GUI.Parent = game:GetService("CoreGui")
            elseif PROTOSMASHER_LOADED then
                GUI.Parent = get_hidden_gui()
            else
                GUI.Parent = game:GetService("CoreGui")
            end
        end

        local ScreenGui = Instance.new("ScreenGui")
        Parent(ScreenGui)

        local CopyScriptPath = Instance.new("TextButton")
        CopyScriptPath.Name = ""
        CopyScriptPath.Parent = ScreenGui -- ‚≠ê MUST be parented to something visible
        CopyScriptPath.BackgroundColor3 = Color3.new(0.000000, 0.000000, 0.000000)
        CopyScriptPath.Position = UDim2.new(0.5, -25, 0, 20)
        CopyScriptPath.Size = UDim2.new(0, 50, 0, 50)
        CopyScriptPath.ZIndex = 15
        CopyScriptPath.Font = Enum.Font.SourceSans
        CopyScriptPath.Text = ""
        CopyScriptPath.TextColor3 = Color3.fromRGB(250, 251, 255)
        CopyScriptPath.TextSize = 16
        CopyScriptPath.BorderSizePixel = 2
        CopyScriptPath.BorderColor3 = Color3.new(1.000000, 1.000000, 1.000000)

        CopyScriptPath.MouseButton1Click:Connect(function()
            Window:Minimize()
        end)

        SaveManager:SetLibrary(Fluent)
        InterfaceManager:SetLibrary(Fluent)

        -- Ignore keys that are used by ThemeManager.
        -- (we dont want configs to save themes, do we?)
        SaveManager:IgnoreThemeSettings()

        -- You can add indexes of elements the save manager should ignore
        SaveManager:SetIgnoreIndexes({})

        -- use case for doing it this way:
        -- a script hub could have themes in a global folder
        -- and game configs in a separate folder per game
        InterfaceManager:SetFolder("FluentScriptHub")
        SaveManager:SetFolder("FluentScriptHub/AnimeWeapons")

        InterfaceManager:BuildInterfaceSection(tabs.Settings)
        SaveManager:BuildConfigSection(tabs.Settings)


        Window:SelectTab(1)

        -- You can use the SaveManager:LoadAutoloadConfig() to load a config
        -- which has been marked to be one that auto loads!
        SaveManager:LoadAutoloadConfig()
        tabs.Settings:AddSection("Only work with lastest config")

    end
end



--part.CanCollide = false -- Players can walk through
